/**
 * File:        modules/LanUdevAuto.ycp
 * Package:     Network configuration
 * Summary:     Udev rules for autoinstallation
 * Authors:     Michal Zugec <mzugec@suse.cz>
 *
 * $Id: Lan.ycp 40537 2007-08-28 13:22:01Z mzugec $
 *
 * Representation of the configuration of network cards.
 */

{
 module     "LanUdevAuto";
 textdomain "network";

 list<map> udev_rules=[];

/**
 *  internal function:
 *  check if old-style (ifcfg-eth-id-..., ifcfg-eth-bus-... is used) or new-style (ifcfg-eth0)
 */
 boolean oldStyle(map ay){
  boolean old_style_found = false;
  foreach(map interface, ay["interfaces"]:[], {
   if (issubstring(interface["device"]:"", "-id-")) old_style_found=true;
   if (issubstring(interface["device"]:"", "-bus-")) old_style_found=true;
  });
  y2milestone("old-style found:%1", old_style_found);
  return old_style_found;
 }

/**
 *  internal function:
 *  for old-slyle create udev rules and rename interface names to new-style
 */
 list<map> createUdevFromIfaceName(list<map> interfaces){
  y2milestone("old-style names for interfaces found - convert into new-style");
  y2internal("interfaces %1", interfaces);
  integer pos=0;
  list<map> tmp_interfaces=[];
  foreach(map interface, interfaces, {
   if (issubstring(interface["device"]:"", "-id-")||issubstring(interface["device"]:"", "-bus-")){
    string value = splitstring(interface["device"]:"", "-")[2]:"";
    string rule="ATTR{address}";
    if (splitstring(interface["device"]:"", "-")[1]:"" == "bus") rule = "KERNELS";
    interface["device"]=sformat("eth%1", pos);
    udev_rules = add(udev_rules,
				$[
				  "rule"  : rule,
				  "value" : value,
				  "name"  : interface["device"]:""
				 ]);
    tmp_interfaces=add(tmp_interfaces, interface);
   }
   pos=pos+1;
  });
  y2milestone("converted interfaces: %1", tmp_interfaces);
  return tmp_interfaces;
 }

 global define boolean Import(map settings) {
  if (oldStyle(settings)) settings["interfaces"] = createUdevFromIfaceName(settings["interfaces"]:[]);
	else udev_rules = settings["net-udev"]:[];
  y2internal("interfaces: %1", settings["interfaces"]:[]);
  y2internal("udev rules:%1", udev_rules);
  return true;
 }

 global define boolean Write(){
 list<string> comment = ["# Generated by autoyast",
			"# program run by the persistent-net-generator.rules rules file.",
			"#",
			"# You can modify it, as long as you keep each rule on a single line." ];
  list<string> rules = [];
  foreach(map rule, udev_rules, {
   rules = add(rules, sformat("SUBSYSTEM==\"net\", DRIVERS==\"?*\", %1==\"%2\", NAME=\"%3\"",
						rule["rule"]:"", rule["value"]:"", rule["name"]:""));
  });
  if (size(rules)>0){
   y2milestone("Writing AY udev rules for network (will replace original rules from 1st stage)");
   SCR::Write(.udev_persistent.rules_comment, comment);
   SCR::Write(.udev_persistent.rules, rules);
  } else
     y2milestone("No udev rules defined by AY, nothing to write (keep original file)");
  return true;
 }


}
